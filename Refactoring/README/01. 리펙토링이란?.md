# 리펙토링이란?
## 리펙토링
- 외부에서 보는 프로그램의 기능은 변하지 않고 프로그램의 내부 구조를 개선하는 것
- 프로그램의 동작이 변하지 않음을 증명하기 위해 유닛테스트가 필요
    - 테스트 -> 리펙토링 -> 테스트
- 디버깅, 기능 추가는 리펙토링이 아니다.

## 리펙토링의 여러가지 방법
- 메서드나 클래스가 겹치는 경우 -> 분리한다.
- 메서드나 클래스의 기능이 너무 많고 긴 경우 -> 메서드와 클래스를 따로 추출한다.
- 변수, 메서드, 필드명, 패키지명 등이 안맞는 경우 -> 적절한 이름은 프로그래밍에서 매우 
중요하므로 이해하기 쉽게 변경한다.
- public으로 선언된 것이 너무 많은 경우 -> 인스턴스 이름을 숨기고 싶을 때는 팩토리
메서드 방법 등을 활용함
- 객체 지향적인 프로그래밍이 아닌 경우 -> switch 문이나 if-else if 문의 남용으로
여러 분류 조건이 반복되는 경우엔 클래스화 할 수 있음

## 코드에서 나는 악취 (smell)
- 너무 긴 메서드 : 메서드가 너무 길다.
- 방대한 클래스 : 클래스의 필드와 메서드가 너무 많다.
- 변경 발산 : 기능의 변경 시 많은 곳을 수정해야 한다.
- 속성, 조작 끼어들기 : 언제나 다른 클래스의 내용을 수정하게 하는 클래스가 있다.
- if, switch 문 : 조건분기가 너무 반복적이고 많다.
- 과다한 매개 변수 : 메서드가 받는 매개 변수의 수가 너무 많다.
- 기본 타입에 집착 : 객체화 하지 않고, 기본 타입만 사용한다.
- 게으른 클래스 : 하는 일이 없는 클래스
- 의심스러운 일반화 : 언젠가는 상속하겠지 하면서 만들어놓은 상위 클래스
- 메세지 연쇄 : 메서드 호출시 연쇄가 너무 길다.
- 너무 많은 주석 : 프로그램의 부족함을 주석으로 설명해 놓음

## 리펙토링을 왜 하는가?
- 프로그램의 수정, 기능 추가를 쉽게 하기 위해 (유지보수 편하게)
- 버그 수정이 편하게
- 알기 쉬운 코드로 여러 명이 공유하기 쉽게

## 리펙토링 카탈로그
- 각 리펙토링의 목적과 절차를 설명
- 이름, 상황, 문제, 해법, 결과, 방법, 관련 항목등을 기술
